Lab 2
====================
First
---------------
* 已经给出的代码已经比较完善，但是没有对链表进行排序，在free和alloc部分增加排序逻辑即可.
* first fit算法最大的缺憾就是会造成比较大程度的内存碎片化，考虑到这种可能，我的想法就是不再按照地址进行排序，而是按照空闲块大小进行排序，空闲块大的排后面，每次修改均需进行重新排序，但这样的性能就不如现在的性能。

Second
------------------------
* PDE:bit 0:是否存在，bit 1：是否可写，bit 2：用户态还是内核态，用于权限控制，bit 4 5：PWT和PCD决定page的内存类型，bit 5：page是否被访问过，bit 6：是否向page（该范围内）写入内容，用于换入换出，bit 7：页大小，必须为1，bit 8：是否为全局页，bit 22 - 31：第二级页表的物理地址.
* PTE:与上面基本一致，但bit 7：表示是否开启PAT.
* 硬件将保护现场，并将异常号压入栈，跳转到相应异常处理程序处.
* 实现过程:这个我做实验的时候比较曲折,调试了将近2个小时,我起初认为这个函数将会在分页机制开启后调用.结果总是panic,后来进行栈追踪,发现调用发生在分页开启前.
* 先判断对应的二级表是否存在,存在直接返回从一级表中获得的地址,这里要做一下转换,转换成虚拟地址.不存在则去申请一个page,作为二级表,并将相应的一级表项赋值.之后再返回.在此之前,要判断是否需要创建.

Third
----------------------------
* 有;实际上是一种一一对应的关系,page中每一个变量将与从vpt+ppn(kernbase)的表项对应.
* 实现过程:有了上一个函数的经验,这个函数很快就可以完成.先判读参数是否合法,接着获得所映射带的frame,递减引用计数,为0则释放.最后解除映射,并无效tlb.
