Practice One
===========================
First
-----------
* 硬盘主引导扇区应该具有的特征：
* 1.应该位于硬盘的第一扇区.
* 2.应该存放着系统引导程序.

Second
---------------------------
* 1.由于在Makefile中已经写好先关命令，直接`make qemu`即可
* 2.执行远程调试命令`target remote localhost:1234`
* 3.设置断点`b *0x7c00`,可以先设置`layout regs`.
* 4.观察断点和寄存器.

Third
--------------------------
* 1.首先关中断，设置段寄存器为0.
* 2.开始设置A20，先等待不忙，向0x64 IO端口发写8042的p2端口命令，
等待不忙，通过0x60 IO端口，写入数据，开启A20.
* 3.开始设置初始的GDT，初始GDT只有3个表，分别是空表（根据Intel官方文档，第一个表一定是空表）数据段表，代码段表。之后开启保护模式。
* 4.设置段寄存器，设置好ebp和esp，esp指向开始的地方，函数调用栈初始化完毕。
* 5.执行 bootmain 函数，注意，这个函数不可能会返回。

Fourth
--------------------
* 1.在bootmain.c中有三个封装函数，waitdisk（）：等待硬盘准备完毕，readsect（）：读取一个扇区的内容，readseg（）：通过调用前2个封装函数，将一定偏远的一定量数据读入指定内存.
* 2.bootmain函数负责装载镜像进入内存，借助readseg函数。在将elf头转载进内存后，根据头转载各个段，之后将CPU控制权移交给内核入口。

Fifth
--------------------
* 针对最后一行的含义，ebp是bootasm.S里最后装载esp时候形成的，所以值+4既是0x7c00，而eip就是bootasm.S里最后一条指令`jmp spin`的地址（当然永远不可能执行）.
* 先读出现在的栈帧，依靠一个一级一级的往上读，直到读出的栈帧为0，说明到了最大深度。通过栈帧可以获得上一级的调用地址（call的下一个指令地址），借助辅助函数可以输出相关的信息.
Sixth
------------------------
* 一个表项占8个字节，其中bit 0-15是地址的低16位，bit 16-31是段选择符号（由于是平坦地址空间，所以实际上，offset就是地址），bit 32-47是一些属性信息，bit 48-61是地址高16位
* 中断初始化：通过全局变量`extern uintptr_t __vectors[]`获得处理入口地址，之后初始化相应的表，根据tools中的生成器，可以知道哪些作为中断哪些作为异常，同时0x80向量作为系统调用的软中断，其DPL设置为3.
* 处理timer中断：设置一个全局计数器即可，已经给出.
