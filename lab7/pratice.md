Lab 7
===============
First
-----------
* 信号量的结构由2部分组成,变量和等待队列.变量的操作是互斥的和原子的,这一点在内核中由关闭中断来保证,这仅仅适合于单处理机的机器.down函数作用:满足条件时候,减小数值,并返回.当数值小于等于0的时候,把自己放入等待队列睡眠.up函数:先测试有没有进程在队列睡眠,有就唤醒一个,没有则增加数值.
* 用户态的实现机制同内核态类似,不过使用suspend之类的函数放弃cpu挂起自身,用wake之类的函数完成唤醒.针对数值测试的原子操作则需要硬件或者内核支持.

Second
---------------
* 实现的基础在于信号量,其中信号量的获得与释放关系十分微妙.wait函数会首先判断是否有因为激活而睡眠的进程,有则唤醒,没有则放弃信号量并睡眠.signal函数则判断有没有等待条件的进程,有则唤醒它并睡眠.
* 用户态的实现同内核态类似.
* 现在实现仍存在问题,在执行完matrix后会提前结束.通过对照答案代码,找到了一个存在问题的地方,fork处,在getpid时候没关闭中断.修改后仍然有相同的问题!
* 下午又调试了一下午终于找到原因了,原来在实现cond_wait函数的时候错把自增写成自减了.真是要细心啊!不过,脑子不清醒总是容易出这种低级错误orz.
