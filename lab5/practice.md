Lab 5
===============
First
---------------
* 在执行完do_exec后,中断帧已经被重新设置,当然在此之前,地址空间也已经被重新设置了,之后从中断返回,执行第一条指令(当然在其他的内核中在从中断返回的时候可能会被抢占,需要等待到被调度才可以开始执行指令).

Second
------------------
* 在copy_range函数中,并不进行物理内存申请,直接将子进程相应页表映射到父进程相应的物理页上,不过需要做一个特殊的标记,同时将页属性设置为只读.
* 在处理页异常中可以识别出相应的特殊页,为这种页分配内存,并拷贝原来的内容.

Third
-------------
* fork对进程本身状态没有影响,但会将子进程从未初始化变成可执行(这么说似乎也有问题,因为本来就是产生新的进程).exec对进程状态没有影响(在实际内核中,他会修该pcb的一些内容).wait在没有得到相应进程退出状态时候,会让进程进入阻塞态.而exit会使进程进入僵尸态直到父进程将他回收.
* fork:fork将会将当前进程所有的东西拷贝出来作为产生新进程,他首先获得一个pcb,再获得新进程的id(这个是不会拷贝的),设置其父进程为当前进程,设置亲属关系.将地址空间做完全拷贝,再申请一块内核栈,最后拷贝其运行上下文,其实就是设置其中断帧.
最后设置其状态为可调度.注意,do_fork设置的调度上下文的eip是forkret,这里是特殊处理了的,这样调度的时候直接先执行到这,再从中断返回.
* exec:先清空其地址空间,再重新设置地址空间,这一过程涉及将文件加载到相应的虚拟地址空间,最后设置中断帧,返回.
* exit:首先销毁地址空间,设置自身为僵尸态,再检查是否有子进程,将子进程交给init托管(这个内核设计导致不会出现僵尸进程,而linux内核是会出现僵尸进程的).最后重新调度.
* wait:先寻找指定进程是否处于僵尸态,找到了返回退出码并进行最后的清理,没找到则将自己处于阻塞态,重新调度.
